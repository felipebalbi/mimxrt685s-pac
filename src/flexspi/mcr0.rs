#[doc = "Register `MCR0` reader"]
pub type R = crate::R<Mcr0Spec>;
#[doc = "Register `MCR0` writer"]
pub type W = crate::W<Mcr0Spec>;
#[doc = "Field `SWRESET` reader - Software Reset"]
pub type SwresetR = crate::BitReader;
#[doc = "Field `SWRESET` writer - Software Reset"]
pub type SwresetW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `MDIS` reader - Module Disable"]
pub type MdisR = crate::BitReader;
#[doc = "Field `MDIS` writer - Module Disable"]
pub type MdisW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Sample Clock source selection for Flash Reading\n\nValue on reset: 0"]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Rxclksrc {
    #[doc = "0: Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    Rxclksrc0 = 0,
    #[doc = "1: Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    Rxclksrc1 = 1,
    #[doc = "3: Flash provided Read strobe and input from DQS pad"]
    Rxclksrc3 = 3,
}
impl From<Rxclksrc> for u8 {
    #[inline(always)]
    fn from(variant: Rxclksrc) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for Rxclksrc {
    type Ux = u8;
}
impl crate::IsEnum for Rxclksrc {}
#[doc = "Field `RXCLKSRC` reader - Sample Clock source selection for Flash Reading"]
pub type RxclksrcR = crate::FieldReader<Rxclksrc>;
impl RxclksrcR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<Rxclksrc> {
        match self.bits {
            0 => Some(Rxclksrc::Rxclksrc0),
            1 => Some(Rxclksrc::Rxclksrc1),
            3 => Some(Rxclksrc::Rxclksrc3),
            _ => None,
        }
    }
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    #[inline(always)]
    pub fn is_rxclksrc_0(&self) -> bool {
        *self == Rxclksrc::Rxclksrc0
    }
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    #[inline(always)]
    pub fn is_rxclksrc_1(&self) -> bool {
        *self == Rxclksrc::Rxclksrc1
    }
    #[doc = "Flash provided Read strobe and input from DQS pad"]
    #[inline(always)]
    pub fn is_rxclksrc_3(&self) -> bool {
        *self == Rxclksrc::Rxclksrc3
    }
}
#[doc = "Field `RXCLKSRC` writer - Sample Clock source selection for Flash Reading"]
pub type RxclksrcW<'a, REG> = crate::FieldWriter<'a, REG, 2, Rxclksrc>;
impl<'a, REG> RxclksrcW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    #[inline(always)]
    pub fn rxclksrc_0(self) -> &'a mut crate::W<REG> {
        self.variant(Rxclksrc::Rxclksrc0)
    }
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    #[inline(always)]
    pub fn rxclksrc_1(self) -> &'a mut crate::W<REG> {
        self.variant(Rxclksrc::Rxclksrc1)
    }
    #[doc = "Flash provided Read strobe and input from DQS pad"]
    #[inline(always)]
    pub fn rxclksrc_3(self) -> &'a mut crate::W<REG> {
        self.variant(Rxclksrc::Rxclksrc3)
    }
}
#[doc = "The serial root clock could be divided inside FlexSPI wrapper. Refer Clocks chapter for more details on clocking.\n\nValue on reset: 0"]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Serclkdiv {
    #[doc = "0: Divided by 1"]
    Serclkdiv0 = 0,
    #[doc = "1: Divided by 2"]
    Serclkdiv1 = 1,
    #[doc = "2: Divided by 3"]
    Serclkdiv2 = 2,
    #[doc = "3: Divided by 4"]
    Serclkdiv3 = 3,
    #[doc = "4: Divided by 5"]
    Serclkdiv4 = 4,
    #[doc = "5: Divided by 6"]
    Serclkdiv5 = 5,
    #[doc = "6: Divided by 7"]
    Serclkdiv6 = 6,
    #[doc = "7: Divided by 8"]
    Serclkdiv7 = 7,
}
impl From<Serclkdiv> for u8 {
    #[inline(always)]
    fn from(variant: Serclkdiv) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for Serclkdiv {
    type Ux = u8;
}
impl crate::IsEnum for Serclkdiv {}
#[doc = "Field `SERCLKDIV` reader - The serial root clock could be divided inside FlexSPI wrapper. Refer Clocks chapter for more details on clocking."]
pub type SerclkdivR = crate::FieldReader<Serclkdiv>;
impl SerclkdivR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Serclkdiv {
        match self.bits {
            0 => Serclkdiv::Serclkdiv0,
            1 => Serclkdiv::Serclkdiv1,
            2 => Serclkdiv::Serclkdiv2,
            3 => Serclkdiv::Serclkdiv3,
            4 => Serclkdiv::Serclkdiv4,
            5 => Serclkdiv::Serclkdiv5,
            6 => Serclkdiv::Serclkdiv6,
            7 => Serclkdiv::Serclkdiv7,
            _ => unreachable!(),
        }
    }
    #[doc = "Divided by 1"]
    #[inline(always)]
    pub fn is_serclkdiv_0(&self) -> bool {
        *self == Serclkdiv::Serclkdiv0
    }
    #[doc = "Divided by 2"]
    #[inline(always)]
    pub fn is_serclkdiv_1(&self) -> bool {
        *self == Serclkdiv::Serclkdiv1
    }
    #[doc = "Divided by 3"]
    #[inline(always)]
    pub fn is_serclkdiv_2(&self) -> bool {
        *self == Serclkdiv::Serclkdiv2
    }
    #[doc = "Divided by 4"]
    #[inline(always)]
    pub fn is_serclkdiv_3(&self) -> bool {
        *self == Serclkdiv::Serclkdiv3
    }
    #[doc = "Divided by 5"]
    #[inline(always)]
    pub fn is_serclkdiv_4(&self) -> bool {
        *self == Serclkdiv::Serclkdiv4
    }
    #[doc = "Divided by 6"]
    #[inline(always)]
    pub fn is_serclkdiv_5(&self) -> bool {
        *self == Serclkdiv::Serclkdiv5
    }
    #[doc = "Divided by 7"]
    #[inline(always)]
    pub fn is_serclkdiv_6(&self) -> bool {
        *self == Serclkdiv::Serclkdiv6
    }
    #[doc = "Divided by 8"]
    #[inline(always)]
    pub fn is_serclkdiv_7(&self) -> bool {
        *self == Serclkdiv::Serclkdiv7
    }
}
#[doc = "Field `SERCLKDIV` writer - The serial root clock could be divided inside FlexSPI wrapper. Refer Clocks chapter for more details on clocking."]
pub type SerclkdivW<'a, REG> = crate::FieldWriter<'a, REG, 3, Serclkdiv, crate::Safe>;
impl<'a, REG> SerclkdivW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "Divided by 1"]
    #[inline(always)]
    pub fn serclkdiv_0(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv0)
    }
    #[doc = "Divided by 2"]
    #[inline(always)]
    pub fn serclkdiv_1(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv1)
    }
    #[doc = "Divided by 3"]
    #[inline(always)]
    pub fn serclkdiv_2(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv2)
    }
    #[doc = "Divided by 4"]
    #[inline(always)]
    pub fn serclkdiv_3(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv3)
    }
    #[doc = "Divided by 5"]
    #[inline(always)]
    pub fn serclkdiv_4(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv4)
    }
    #[doc = "Divided by 6"]
    #[inline(always)]
    pub fn serclkdiv_5(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv5)
    }
    #[doc = "Divided by 7"]
    #[inline(always)]
    pub fn serclkdiv_6(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv6)
    }
    #[doc = "Divided by 8"]
    #[inline(always)]
    pub fn serclkdiv_7(self) -> &'a mut crate::W<REG> {
        self.variant(Serclkdiv::Serclkdiv7)
    }
}
#[doc = "Half Speed Serial Flash access Enable.\n\nValue on reset: 0"]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Hsen {
    #[doc = "0: Disable divide by 2 of serial flash clock for half speed commands."]
    Hsen0 = 0,
    #[doc = "1: Enable divide by 2 of serial flash clock for half speed commands."]
    Hsen1 = 1,
}
impl From<Hsen> for bool {
    #[inline(always)]
    fn from(variant: Hsen) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `HSEN` reader - Half Speed Serial Flash access Enable."]
pub type HsenR = crate::BitReader<Hsen>;
impl HsenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Hsen {
        match self.bits {
            false => Hsen::Hsen0,
            true => Hsen::Hsen1,
        }
    }
    #[doc = "Disable divide by 2 of serial flash clock for half speed commands."]
    #[inline(always)]
    pub fn is_hsen_0(&self) -> bool {
        *self == Hsen::Hsen0
    }
    #[doc = "Enable divide by 2 of serial flash clock for half speed commands."]
    #[inline(always)]
    pub fn is_hsen_1(&self) -> bool {
        *self == Hsen::Hsen1
    }
}
#[doc = "Field `HSEN` writer - Half Speed Serial Flash access Enable."]
pub type HsenW<'a, REG> = crate::BitWriter<'a, REG, Hsen>;
impl<'a, REG> HsenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disable divide by 2 of serial flash clock for half speed commands."]
    #[inline(always)]
    pub fn hsen_0(self) -> &'a mut crate::W<REG> {
        self.variant(Hsen::Hsen0)
    }
    #[doc = "Enable divide by 2 of serial flash clock for half speed commands."]
    #[inline(always)]
    pub fn hsen_1(self) -> &'a mut crate::W<REG> {
        self.variant(Hsen::Hsen1)
    }
}
#[doc = "Doze mode enable bit\n\nValue on reset: 0"]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Dozeen {
    #[doc = "0: Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    Dozeen0 = 0,
    #[doc = "1: Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    Dozeen1 = 1,
}
impl From<Dozeen> for bool {
    #[inline(always)]
    fn from(variant: Dozeen) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `DOZEEN` reader - Doze mode enable bit"]
pub type DozeenR = crate::BitReader<Dozeen>;
impl DozeenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Dozeen {
        match self.bits {
            false => Dozeen::Dozeen0,
            true => Dozeen::Dozeen1,
        }
    }
    #[doc = "Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    #[inline(always)]
    pub fn is_dozeen_0(&self) -> bool {
        *self == Dozeen::Dozeen0
    }
    #[doc = "Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    #[inline(always)]
    pub fn is_dozeen_1(&self) -> bool {
        *self == Dozeen::Dozeen1
    }
}
#[doc = "Field `DOZEEN` writer - Doze mode enable bit"]
pub type DozeenW<'a, REG> = crate::BitWriter<'a, REG, Dozeen>;
impl<'a, REG> DozeenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    #[inline(always)]
    pub fn dozeen_0(self) -> &'a mut crate::W<REG> {
        self.variant(Dozeen::Dozeen0)
    }
    #[doc = "Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    #[inline(always)]
    pub fn dozeen_1(self) -> &'a mut crate::W<REG> {
        self.variant(Dozeen::Dozeen1)
    }
}
#[doc = "This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2).\n\nValue on reset: 0"]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Sckfreerunen {
    #[doc = "0: Disable."]
    Sckfreerunen0 = 0,
    #[doc = "1: Enable."]
    Sckfreerunen1 = 1,
}
impl From<Sckfreerunen> for bool {
    #[inline(always)]
    fn from(variant: Sckfreerunen) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `SCKFREERUNEN` reader - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
pub type SckfreerunenR = crate::BitReader<Sckfreerunen>;
impl SckfreerunenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Sckfreerunen {
        match self.bits {
            false => Sckfreerunen::Sckfreerunen0,
            true => Sckfreerunen::Sckfreerunen1,
        }
    }
    #[doc = "Disable."]
    #[inline(always)]
    pub fn is_sckfreerunen_0(&self) -> bool {
        *self == Sckfreerunen::Sckfreerunen0
    }
    #[doc = "Enable."]
    #[inline(always)]
    pub fn is_sckfreerunen_1(&self) -> bool {
        *self == Sckfreerunen::Sckfreerunen1
    }
}
#[doc = "Field `SCKFREERUNEN` writer - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
pub type SckfreerunenW<'a, REG> = crate::BitWriter<'a, REG, Sckfreerunen>;
impl<'a, REG> SckfreerunenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disable."]
    #[inline(always)]
    pub fn sckfreerunen_0(self) -> &'a mut crate::W<REG> {
        self.variant(Sckfreerunen::Sckfreerunen0)
    }
    #[doc = "Enable."]
    #[inline(always)]
    pub fn sckfreerunen_1(self) -> &'a mut crate::W<REG> {
        self.variant(Sckfreerunen::Sckfreerunen1)
    }
}
#[doc = "This bit is used to enable/disable data learning feature. When data learning is disabled, the sampling clock phase 0 is always used for RX data sampling even if LEARN instruction is correctly executed.\n\nValue on reset: 1"]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Learnen {
    #[doc = "0: Disable."]
    Learnen0 = 0,
    #[doc = "1: Enable."]
    Learnen1 = 1,
}
impl From<Learnen> for bool {
    #[inline(always)]
    fn from(variant: Learnen) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `LEARNEN` reader - This bit is used to enable/disable data learning feature. When data learning is disabled, the sampling clock phase 0 is always used for RX data sampling even if LEARN instruction is correctly executed."]
pub type LearnenR = crate::BitReader<Learnen>;
impl LearnenR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Learnen {
        match self.bits {
            false => Learnen::Learnen0,
            true => Learnen::Learnen1,
        }
    }
    #[doc = "Disable."]
    #[inline(always)]
    pub fn is_learnen_0(&self) -> bool {
        *self == Learnen::Learnen0
    }
    #[doc = "Enable."]
    #[inline(always)]
    pub fn is_learnen_1(&self) -> bool {
        *self == Learnen::Learnen1
    }
}
#[doc = "Field `LEARNEN` writer - This bit is used to enable/disable data learning feature. When data learning is disabled, the sampling clock phase 0 is always used for RX data sampling even if LEARN instruction is correctly executed."]
pub type LearnenW<'a, REG> = crate::BitWriter<'a, REG, Learnen>;
impl<'a, REG> LearnenW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disable."]
    #[inline(always)]
    pub fn learnen_0(self) -> &'a mut crate::W<REG> {
        self.variant(Learnen::Learnen0)
    }
    #[doc = "Enable."]
    #[inline(always)]
    pub fn learnen_1(self) -> &'a mut crate::W<REG> {
        self.variant(Learnen::Learnen1)
    }
}
#[doc = "Field `IPGRANTWAIT` reader - Time out wait cycle for IP command grant."]
pub type IpgrantwaitR = crate::FieldReader;
#[doc = "Field `IPGRANTWAIT` writer - Time out wait cycle for IP command grant."]
pub type IpgrantwaitW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
#[doc = "Field `AHBGRANTWAIT` reader - Timeout wait cycle for AHB command grant."]
pub type AhbgrantwaitR = crate::FieldReader;
#[doc = "Field `AHBGRANTWAIT` writer - Timeout wait cycle for AHB command grant."]
pub type AhbgrantwaitW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
impl R {
    #[doc = "Bit 0 - Software Reset"]
    #[inline(always)]
    pub fn swreset(&self) -> SwresetR {
        SwresetR::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - Module Disable"]
    #[inline(always)]
    pub fn mdis(&self) -> MdisR {
        MdisR::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bits 4:5 - Sample Clock source selection for Flash Reading"]
    #[inline(always)]
    pub fn rxclksrc(&self) -> RxclksrcR {
        RxclksrcR::new(((self.bits >> 4) & 3) as u8)
    }
    #[doc = "Bits 8:10 - The serial root clock could be divided inside FlexSPI wrapper. Refer Clocks chapter for more details on clocking."]
    #[inline(always)]
    pub fn serclkdiv(&self) -> SerclkdivR {
        SerclkdivR::new(((self.bits >> 8) & 7) as u8)
    }
    #[doc = "Bit 11 - Half Speed Serial Flash access Enable."]
    #[inline(always)]
    pub fn hsen(&self) -> HsenR {
        HsenR::new(((self.bits >> 11) & 1) != 0)
    }
    #[doc = "Bit 12 - Doze mode enable bit"]
    #[inline(always)]
    pub fn dozeen(&self) -> DozeenR {
        DozeenR::new(((self.bits >> 12) & 1) != 0)
    }
    #[doc = "Bit 14 - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
    #[inline(always)]
    pub fn sckfreerunen(&self) -> SckfreerunenR {
        SckfreerunenR::new(((self.bits >> 14) & 1) != 0)
    }
    #[doc = "Bit 15 - This bit is used to enable/disable data learning feature. When data learning is disabled, the sampling clock phase 0 is always used for RX data sampling even if LEARN instruction is correctly executed."]
    #[inline(always)]
    pub fn learnen(&self) -> LearnenR {
        LearnenR::new(((self.bits >> 15) & 1) != 0)
    }
    #[doc = "Bits 16:23 - Time out wait cycle for IP command grant."]
    #[inline(always)]
    pub fn ipgrantwait(&self) -> IpgrantwaitR {
        IpgrantwaitR::new(((self.bits >> 16) & 0xff) as u8)
    }
    #[doc = "Bits 24:31 - Timeout wait cycle for AHB command grant."]
    #[inline(always)]
    pub fn ahbgrantwait(&self) -> AhbgrantwaitR {
        AhbgrantwaitR::new(((self.bits >> 24) & 0xff) as u8)
    }
}
#[cfg(feature = "debug")]
impl core::fmt::Debug for R {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MCR0")
            .field("swreset", &self.swreset())
            .field("mdis", &self.mdis())
            .field("rxclksrc", &self.rxclksrc())
            .field("serclkdiv", &self.serclkdiv())
            .field("hsen", &self.hsen())
            .field("dozeen", &self.dozeen())
            .field("sckfreerunen", &self.sckfreerunen())
            .field("learnen", &self.learnen())
            .field("ipgrantwait", &self.ipgrantwait())
            .field("ahbgrantwait", &self.ahbgrantwait())
            .finish()
    }
}
impl W {
    #[doc = "Bit 0 - Software Reset"]
    #[inline(always)]
    pub fn swreset(&mut self) -> SwresetW<Mcr0Spec> {
        SwresetW::new(self, 0)
    }
    #[doc = "Bit 1 - Module Disable"]
    #[inline(always)]
    pub fn mdis(&mut self) -> MdisW<Mcr0Spec> {
        MdisW::new(self, 1)
    }
    #[doc = "Bits 4:5 - Sample Clock source selection for Flash Reading"]
    #[inline(always)]
    pub fn rxclksrc(&mut self) -> RxclksrcW<Mcr0Spec> {
        RxclksrcW::new(self, 4)
    }
    #[doc = "Bits 8:10 - The serial root clock could be divided inside FlexSPI wrapper. Refer Clocks chapter for more details on clocking."]
    #[inline(always)]
    pub fn serclkdiv(&mut self) -> SerclkdivW<Mcr0Spec> {
        SerclkdivW::new(self, 8)
    }
    #[doc = "Bit 11 - Half Speed Serial Flash access Enable."]
    #[inline(always)]
    pub fn hsen(&mut self) -> HsenW<Mcr0Spec> {
        HsenW::new(self, 11)
    }
    #[doc = "Bit 12 - Doze mode enable bit"]
    #[inline(always)]
    pub fn dozeen(&mut self) -> DozeenW<Mcr0Spec> {
        DozeenW::new(self, 12)
    }
    #[doc = "Bit 14 - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
    #[inline(always)]
    pub fn sckfreerunen(&mut self) -> SckfreerunenW<Mcr0Spec> {
        SckfreerunenW::new(self, 14)
    }
    #[doc = "Bit 15 - This bit is used to enable/disable data learning feature. When data learning is disabled, the sampling clock phase 0 is always used for RX data sampling even if LEARN instruction is correctly executed."]
    #[inline(always)]
    pub fn learnen(&mut self) -> LearnenW<Mcr0Spec> {
        LearnenW::new(self, 15)
    }
    #[doc = "Bits 16:23 - Time out wait cycle for IP command grant."]
    #[inline(always)]
    pub fn ipgrantwait(&mut self) -> IpgrantwaitW<Mcr0Spec> {
        IpgrantwaitW::new(self, 16)
    }
    #[doc = "Bits 24:31 - Timeout wait cycle for AHB command grant."]
    #[inline(always)]
    pub fn ahbgrantwait(&mut self) -> AhbgrantwaitW<Mcr0Spec> {
        AhbgrantwaitW::new(self, 24)
    }
}
#[doc = "Module Control Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Mcr0Spec;
impl crate::RegisterSpec for Mcr0Spec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`mcr0::R`](R) reader structure"]
impl crate::Readable for Mcr0Spec {}
#[doc = "`write(|w| ..)` method takes [`mcr0::W`](W) writer structure"]
impl crate::Writable for Mcr0Spec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets MCR0 to value 0xffff_80c2"]
impl crate::Resettable for Mcr0Spec {
    const RESET_VALUE: u32 = 0xffff_80c2;
}
